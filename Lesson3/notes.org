#+TITLE: Lesson 3
* Introduction
** Software tools
1. Language
2. Functions
* Regular Expressions Review
** Find substring string

- Use find function ::
#+begin_src python
s = 'some long thing with words'
s.find('word') => 21 (-1)
#+end_src
- Use re ::
#+begin_src python
  re.search('baa*!', s)
#+end_src
** Regular Expressions
| special | example | match               | meaning                                   |
|---------+---------+---------------------+-------------------------------------------|
| *       | a*      | '', a, aa, aaa, ... | any length of repeat of the previous char |
| ?       | a?      | '', a               | zero or one appearence                    |
| .       | .       | a, b, c, 7, !,...   | any single character                      |
| ^       | ^b      | ba, bb, ...         | beginning of the line                     |
| $       | a$      | ba, aa              | end of the line                           |
| ''      | ''      | ''                  | empty string                              |
| a       | a       | a                   | single character                          |
* Regular Expressions Review
** [[./rer_quiz1.py][Quiz 1]]
** [[./rer_quiz2.py][Quiz 2]]
** [[./rer_quiz3.py][Quiz 3]]
* Language
** Python
1. Statements
2. Expressions
3. Format
4. Class - operator overloading
** Domain Specific Language
* The Language of Regular Expressions
** Grammar
A description for a specific Language
** API
Application Programming interface
*** Exp:
| lit(s)    | lit('a')                | {a}             |
| seq(x, y) | seq(lit('a'), lit('b')) | {ab}            |
| alt(x, y) | alt(lit('a'), lit('b')) | {a, b}          |
| star(x)   | star(lit('a'))          | {'', a, aa,...} |
| oneof(c)  | oneof('abc')            | {a, b, c}       |
| eol       | eol                     | {''}            |
| dot       | dot                     | {a, b, c, ...}  |
* Specifications
* Concept Inventory
- pattern
- text —— result
- control over iteration
- partial result
'a*b+' -> 'aaab' -> 'ab' or 'aab' or 'aaab'
[[./matchset.py][set of remainders]]
* [[./filling_out_the_api.py][Filling Out The API]]
* [[./search_and_match.py][Search and Match]]
- match(p, t) ::
Match pattern against start of text; return longest match found or None.
- search(p, t) ::
Match pattern anywhere in text; return longest earliest match or None.
- matchset(p, t) ::
Match pattern at start of text; return a set of remainders of text.
* Compiling
| pattern      | lanuage         | compiler                     |
|--------------+-----------------+------------------------------|
| (a \vert b)+ | {a,b,ab,ba,...} | compile(pattern)->c->c(text) |
* Lower Level Compilers
#+begin_src python
pat = lit('a')
pat
>>> function<lambda> ...
pat('a string')
>>> set([' string'])

pat2 = plus(pat)
pat2
>>> function<lambda> ...
pat2('aaaaab')

matchset(pat2, 'aaaaab')
#+end_src

** Pros
- Python Functions :: flexibility
- Language VM :: Machine Instructions
* [[./alt.py][Alt]]
* [[./simple_compilers.py][Simple Compilers]]
* Recognizers and Generators
- Recognizers :: match(pat, text) -> txt | None
- Generator :: gen(pat) -> L
  - Finite Language :: (a | b)(a | b) = {aa, ab, ba, bb}
  - Inifinite Language ::
       a* = { , a, aa, aaa, ...}

       pat({int}) -> {str}

       pat = a*

       pat({1, 2, 3}) -> {a, aa, aaa}
* Avoid Repetition
* Genseq
* Induction
:LOGBOOK:
CLOCK: [2015-02-25 Wed 10:10]--[2015-02-25 Wed 10:12] =>  0:02
:END:
[2015-02-25 Wed 10:10]
** Star
** Plus
** Induction
Ns = 1
* Testing Genseq
:LOGBOOK:
CLOCK: [2015-02-25 Wed 10:13]--[2015-02-25 Wed 10:15] =>  0:02
:END:
[2015-02-25 Wed 10:13]
* Theory and Practice
:LOGBOOK:
CLOCK: [2015-02-25 Wed 10:16]--[2015-02-25 Wed 10:33] =>  0:17
:END:
[2015-02-25 Wed 10:15]
* Theory
[2015-02-25 Wed 10:20]

pattern + grammer -> language

interpreter -> grammer

compiler -> pattern
* Practice
- reg exp ::
- interpreters :: more expresive and more natural
- functions ::
              more composable

              and give us the ability to control over
              time (do it now or do it later)
[2015-02-25 Wed 10:21]
* Changing Seq
:LOGBOOK:
CLOCK: [2015-02-25 Wed 10:34]--[2015-02-25 Wed 10:45] =>  0:11
:END:
[2015-02-25 Wed 10:34]
** Refactoring
[2015-02-25 Wed 10:39]
- Backward compatible
- Internal / External
* Changing Functions
[2015-02-25 Wed 10:45]
* Function Mapping
:LOGBOOK:
CLOCK: [2015-02-25 Wed 10:46]--[2015-02-25 Wed 10:47] =>  0:01
:END:
[2015-02-25 Wed 10:46]
Adapter
